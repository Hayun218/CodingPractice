## BOJ 6209 제자리 멀리뛰기

- 문제 푼 날짜 or 문서 작성 날짜: 2020.4.2 (목)
- 문제링크: [BOJ6209](https://www.acmicpc.net/problem/6209)

### 내가 이해한 문제 내용

- 돌섬에서 탈출구 사이에 n개의 작은 돌섬이 있고 그 중 m개의 돌섬을 없애는데 점프한 거리의 최솟값을 최대한 크게 즉, 각 돌섬 사이의 거리를 최대한으로 만들 수 있도록 m개의 돌섬을 제거한다. 이 때 점프하는 최소거리의 최댓값을 구하는 프로그램

-----

- 입력: 
  - 돌섬과 탈출구까지의 거리 d(1 ≤ d ≤ 1,000,000,000)
  - 작은 돌섬의 갯수 n개 (0 ≤ n ≤ 50,000)
  - 제거할 수 있는 작은 돌섬의 갯수 m개 (0 ≤ m ≤ n)
  - n개 돌섬의 위치 (갇힌 섬으로 부터 얼마나 떨어져 있는지)
- 출력: n개의 돌섬 중 m개를 제거하였을 때 학생들이 점프하는 최소거리의 최댓값

### 접근방식

- 이분탐색_TIL 활용하여 복습! 먼저 함

- 섬으로 부터의 거리가 주어지기에 sort를 통해 오름차순으로 정렬하고 각 돌섬 사이사이의 거리를 구한다.
- 그 구한 거리값이 최대가 되도록 하는 m개의 돌섬을 제거한다.

---

- mid를 돌과 돌 사이의 거리라고 생각하면서 이분탐색 진행

1. 돌과 돌 사이의 거리가 mid보다 작다면 cnt++ =>  m개를 제거할 예정이니 m개까지는 최솟값의 최대인 mid보다 작아도 허용가능하니까
2. cnt의 값이 mid와 같다면 해당 mid가 정답! 중간과정은 일반적인 이분탐색



### 어려웠던 점 (놓쳤던 부분)

- 돌과 돌 사이라고 생각해서 바로 양옆 돌만 생각했는데 두번 떨어져 있는 것과의 거리도 mid 이하 일 수도 있기에 pre 변수 하나를 더 두어서 고려했어야 했다.
- 위에 사항도 고쳐서 돌렸는데 계속 틀렸다고 나옴... => 시작점! 즉 dn이 0인 경우를 넣어주지 않았었다 => 넣었는데도.. 계속 틀렸다고 뜬다 ㅠㅠ 
  - 이유:

```c++
if(cnt > m)
      right = mid - 1;
    else if (cnt < m)
      left = mid + 1;
    else {
      ans = mid;
      break;
    } 
// 답 입력을 이렇게 하니까 틀렸다고 나옴 차이점을 아직 모르겠다 ㅠ 그래도 일단 수정 후 "맞았습니다"
```



##### 참고자료

- [코드로직참고](http://wookje.dance/2018/03/30/boj-6209-제자리-멀리뛰기/)

